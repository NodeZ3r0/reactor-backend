#!/usr/bin/env python3\n"""\nMCP Server - Model Context Protocol Server for vault.wopr.systems\nComplete production-ready implementation with multi-user authentication\n"""\n\nfrom fastapi import FastAPI, HTTPException, Security, Depends\nfrom fastapi.security import APIKeyHeader, HTTPBearer, HTTPAuthorizationCredentials\nfrom pydantic import BaseModel\nfrom typing import Optional, List, Dict\nimport asyncpg\nimport subprocess\nimport os\nimport git\nfrom datetime import datetime\nimport json\nimport httpx\nfrom dotenv import load_dotenv\nfrom auth_middleware import extract_user_from_token, User\n\nload_dotenv()\n\napp = FastAPI(\n    title="MCP Agent Server - vault.wopr.systems",\n    description="Model Context Protocol Server for AI Coding Agent",\n    version="1.0.0"\n)\n\n# Configuration\nAPI_KEY_HEADER = APIKeyHeader(name="X-API-Key", auto_error=False)\nVALID_API_KEY = os.getenv("MCP_API_KEY")\nGITHUB_TOKEN = os.getenv("GITHUB_TOKEN")\nGITHUB_ORG = os.getenv("GITHUB_ORG")\nGITHUB_API = os.getenv("GITHUB_API", "https://api.github.com")\n\n# Multi-user authentication\nsecurity = HTTPBearer(auto_error=False)\n\n# Database configuration (Hetzner WOPR via Nebula)\nDB_CONFIG = {\n    "host": os.getenv("DB_HOST", "10.0.1.1"),\n    "port": int(os.getenv("DB_PORT", 5432)),\n    "database": os.getenv("DB_NAME", "agent_memory"),\n    "user": os.getenv("DB_USER", "agent_user"),\n    "password": os.getenv("DB_PASSWORD")\n}\n\n# Paths\nREPOS_BASE_PATH = os.getenv("REPOS_BASE_PATH")\nALLOWED_REPOS = [r.strip() for r in os.getenv("ALLOWED_REPOS", "").split(",") if r.strip()]\n\nos.makedirs(REPOS_BASE_PATH, exist_ok=True)\n\n\nclass DBManager:\n    """Database connection pool manager"""\n    def __init__(self):\n        self.pool = None\n\n    async def init_pool(self):\n        """Initialize connection pool"""\n        self.pool = await asyncpg.create_pool(**DB_CONFIG, min_size=5, max_size=20)\n\n    async def execute_with_user_context(self, user: User, query: str, *args):\n        """Execute query with RLS user context"""\n        async with self.pool.acquire() as conn:\n            async with conn.transaction():\n                await conn.execute(f"SET LOCAL app.current_user_id = '{user.id}'")\n                role = 'admin' if user.is_admin else 'user'\n                await conn.execute(f"SET LOCAL app.user_role = '{role}'")\n                return await conn.execute(query, *args)\n\n    async def fetch_with_user_context(self, user: User, query: str, *args):\n        """Fetch query results with RLS user context"""\n        async with self.pool.acquire() as conn:\n            async with conn.transaction():\n                await conn.execute(f"SET LOCAL app.current_user_id = '{user.id}'")\n                role = 'admin' if user.is_admin else 'user'\n                await conn.execute(f"SET LOCAL app.user_role = '{role}'")\n                return await conn.fetch(query, *args)\n\n    async def fetchval_with_user_context(self, user: User, query: str, *args):\n        """Fetch single value with RLS user context"""\n        async with self.pool.acquire() as conn:\n            async with conn.transaction():\n                await conn.execute(f"SET LOCAL app.current_user_id = '{user.id}'")\n                role = 'admin' if user.is_admin else 'user'\n                await conn.execute(f"SET LOCAL app.user_role = '{role}'")\n                return await conn.fetchval(query, *args)\n\n    async def log_phase(self, session_id, phase_name, model, input_ctx, output, tokens, duration, success, error=None):\n        """Log a phase execution to database"""\n        async with self.pool.acquire() as conn:\n            await conn.execute("""\n                INSERT INTO agent_phases\n                (session_id, phase_name, model_used, input_context, output_content,\n                 tokens_used, duration_ms, success, error_message)\n                VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)\n            """, session_id, phase_name, model, input_ctx, output, tokens, duration, success, error)\n\n    async def log_commit(self, session_id, repo, branch, commit_hash, message, files, lines_add, lines_rem):\n        """Log a git commit to database"""\n        async with self.pool.acquire() as conn:\n            await conn.execute("""\n                INSERT INTO git_commits\n                (session_id, repo_name, branch_name, commit_hash, commit_message,\n                 files_changed, lines_added, lines_removed)\n                VALUES ($1, $2, $3, $4, $5, $6, $7, $8)\n            """, session_id, repo, branch, commit_hash, message, files, lines_add, lines_rem)\n\n    async def create_session(self, task_description, metadata=None):\n        """Create a new agent session"""\n        async with self.pool.acquire() as conn:\n            session_id = await conn.fetchval("""\n                INSERT INTO agent_sessions (task_description, metadata)\n                VALUES ($1, $2)\n                RETURNING session_id\n            """, task_description, json.dumps(metadata) if metadata else None)\n            return str(session_id)\n\n    async def update_session_status(self, session_id, status, completed_at=None):\n        """Update session status"""\n        async with self.pool.acquire() as conn:\n            await conn.execute("""\n                UPDATE agent_sessions\n                SET status = $1, completed_at = $2\n                WHERE session_id = $3\n            """, status, completed_at or datetime.now(), session_id)\n\n\ndb = DBManager()\n\n\n# Pydantic Models\nclass GitCloneRequest(BaseModel):\n    repo_url: str\n    branch: Optional[str] = "main"\n\n\nclass FileReadRequest(BaseModel):\n    repo_name: str\n    file_path: str\n\n\nclass FileWriteRequest(BaseModel):\n    repo_name: str\n    file_path: str\n    content: str\n\n\nclass GitCommitRequest(BaseModel):\n    repo_name: str\n    branch: str\n    files: List[str]\n    message: str\n    session_id: str\n\n\nclass BuildRequest(BaseModel):\n    repo_name: str\n    build_command: str\n    session_id: str\n\n\nclass GitHubForkRequest(BaseModel):\n    source_repo: str\n\n\nclass MCPContextRequest(BaseModel):\n    conversation_id: str\n    context_type: str\n    context_data: dict\n    project_id: Optional[str] = None\n\n\n# Authentication dependencies\nasync def get_current_user(credentials: HTTPAuthorizationCredentials = Depends(security)) -> Optional[User]:\n    """Extract user from JWT token"""\n    if not credentials:\n        return None\n    token = credentials.credentials\n    user = extract_user_from_token(token)\n    return user\n\n\nasync def verify_api_key(api_key: str = Security(API_KEY_HEADER)):\n    """Verify API key (legacy authentication)"""\n    if api_key != VALID_API_KEY:\n        raise HTTPException(status_code=403, detail="Invalid API key")\n    return api_key\n\n\nasync def verify_auth(\n    api_key: Optional[str] = Security(API_KEY_HEADER),\n    credentials: Optional[HTTPAuthorizationCredentials] = Depends(security)\n) -> User:\n    """Verify either API key or JWT - backward compatible"""\n    # Try API key first\n    if api_key == VALID_API_KEY:\n        return User('system', 'system', 'system@wopr.systems', is_admin=True)\n\n    # Try JWT\n    if credentials:\n        user = extract_user_from_token(credentials.credentials)\n        if user:\n            return user\n\n    raise HTTPException(status_code=401, detail="Authentication required")\n\n\n# Health check\n@app.get("/health")\nasync def health_check():\n    """Health check endpoint"""\n    return {\n        "status": "healthy",\n        "timestamp": datetime.now().isoformat(),\n        "database": "connected" if db.pool else "disconnected",\n        "postgres_host": DB_CONFIG["host"]\n    }\n\n\n# NEW: Multi-user MCP context endpoints\n@app.post("/api/mcp/context")\nasync def save_mcp_context(request: MCPContextRequest, user: User = Depends(verify_auth)):\n    """Save MCP context for current user"""\n    try:\n        record_id = await db.fetchval_with_user_context(\n            user,\n            """\n            INSERT INTO mcp_context_history\n            (user_id, conversation_id, project_id, context_type, context_data)\n            VALUES ($1, $2, $3, $4, $5)\n            RETURNING id\n            """,\n            user.id,\n            request.conversation_id,\n            request.project_id,\n            request.context_type,\n            json.dumps(request.context_data)\n        )\n\n        return {\n            "success": True,\n            "id": record_id,\n            "user": user.username\n        }\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=f"Failed to save context: {str(e)}")\n\n\n@app.get("/api/mcp/context")\nasync def get_mcp_context(\n    conversation_id: Optional[str] = None,\n    limit: int = 100,\n    user: User = Depends(verify_auth)\n):\n    """Get MCP context for current user"""\n    try:\n        results = await db.fetch_with_user_context(\n            user,\n            """\n            SELECT id, user_id, conversation_id, project_id, context_type,\n                   context_data, created_at\n            FROM mcp_context_history\n            WHERE ($1::text IS NULL OR conversation_id = $1)\n            ORDER BY created_at DESC\n            LIMIT $2\n            """,\n            conversation_id,\n            limit\n        )\n\n        return {\n            "success": True,\n            "data": [dict(r) for r in results],\n            "count": len(results)\n        }\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=f"Failed to fetch context: {str(e)}")\n\n\n@app.get("/api/me")\nasync def get_current_user_info(user: User = Depends(verify_auth)):\n    """Get current user info"""\n    return {\n        "id": user.id,\n        "username": user.username,\n        "email": user.email,\n        "is_admin": user.is_admin\n    }\n\n\n@app.get("/api/admin/dashboard")\nasync def admin_dashboard(limit: int = 200, user: User = Depends(verify_auth)):\n    """Admin dashboard - see all users' context (requires admin role)"""\n    if not user.is_admin:\n        raise HTTPException(status_code=403, detail="Admin access required")\n\n    try:\n        results = await db.fetch_with_user_context(\n            user,\n            """\n            SELECT id, user_id, conversation_id, project_id, context_type,\n                   context_data, created_at\n            FROM mcp_context_history\n            ORDER BY created_at DESC\n            LIMIT $1\n            """,\n            limit\n        )\n\n        return {\n            "success": True,\n            "data": [dict(r) for r in results],\n            "count": len(results),\n            "admin": user.username\n        }\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=f"Failed to fetch dashboard: {str(e)}")\n\n\n# Git Operations\n@app.post("/git/clone")\nasync def git_clone(request: GitCloneRequest, api_key: str = Security(verify_api_key)):\n    """Clone a git repository"""\n    try:\n        repo_name = request.repo_url.split("/")[-1].replace(".git", "")\n        target_path = os.path.join(REPOS_BASE_PATH, repo_name)\n\n        if os.path.exists(target_path):\n            repo = git.Repo(target_path)\n            origin = repo.remote('origin')\n            origin.pull(request.branch)\n            return {"status": "updated", "path": target_path, "message": "Repository updated"}\n\n        git.Repo.clone_from(request.repo_url, target_path, branch=request.branch)\n\n        return {\n            "status": "success",\n            "path": target_path,\n            "repo": repo_name,\n            "branch": request.branch\n        }\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=f"Clone failed: {str(e)}")\n\n\n@app.post("/git/read")\nasync def git_read_file(request: FileReadRequest, api_key: str = Security(verify_api_key)):\n    """Read a file from a git repository"""\n    try:\n        if request.repo_name not in ALLOWED_REPOS:\n            raise HTTPException(status_code=403, detail="Repository not allowed")\n\n        file_path = os.path.join(REPOS_BASE_PATH, request.repo_name, request.file_path)\n\n        if not os.path.exists(file_path):\n            raise HTTPException(status_code=404, detail="File not found")\n\n        if not os.path.abspath(file_path).startswith(os.path.abspath(REPOS_BASE_PATH)):\n            raise HTTPException(status_code=403, detail="Path traversal detected")\n\n        with open(file_path, 'r', encoding='utf-8') as f:\n            content = f.read()\n\n        return {\n            "status": "success",\n            "file_path": request.file_path,\n            "content": content,\n            "size_bytes": len(content)\n        }\n    except HTTPException:\n        raise\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=f"Read failed: {str(e)}")\n\n\n@app.post("/git/write")\nasync def git_write_file(request: FileWriteRequest, api_key: str = Security(verify_api_key)):\n    """Write content to a file in repository"""\n    try:\n        if request.repo_name not in ALLOWED_REPOS:\n            raise HTTPException(status_code=403, detail="Repository not allowed")\n\n        file_path = os.path.join(REPOS_BASE_PATH, request.repo_name, request.file_path)\n\n        if not os.path.abspath(file_path).startswith(os.path.abspath(REPOS_BASE_PATH)):\n            raise HTTPException(status_code=403, detail="Path traversal detected")\n\n        os.makedirs(os.path.dirname(file_path), exist_ok=True)\n\n        backup_content = None\n        if os.path.exists(file_path):\n            with open(file_path, 'r', encoding='utf-8') as f:\n                backup_content = f.read()\n\n        with open(file_path, 'w', encoding='utf-8') as f:\n            f.write(request.content)\n\n        return {\n            "status": "success",\n            "file_path": request.file_path,\n            "had_backup": backup_content is not None,\n            "size_bytes": len(request.content)\n        }\n    except HTTPException:\n        raise\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=f"Write failed: {str(e)}")\n\n\n@app.post("/git/commit")\nasync def git_commit(request: GitCommitRequest, api_key: str = Security(verify_api_key)):\n    """Create a git commit"""\n    try:\n        if request.repo_name not in ALLOWED_REPOS:\n            raise HTTPException(status_code=403, detail="Repository not allowed")\n\n        repo_path = os.path.join(REPOS_BASE_PATH, request.repo_name)\n        repo = git.Repo(repo_path)\n\n        try:\n            repo.git.checkout(request.branch)\n        except:\n            repo.git.checkout('-b', request.branch)\n\n        repo.index.add(request.files)\n        commit = repo.index.commit(request.message)\n        stats = commit.stats.total\n\n        await db.log_commit(\n            request.session_id,\n            request.repo_name,\n            request.branch,\n            commit.hexsha,\n            request.message,\n            len(request.files),\n            stats['insertions'],\n            stats['deletions']\n        )\n\n        return {\n            "status": "success",\n            "commit_hash": commit.hexsha,\n            "files_changed": len(request.files),\n            "lines_added": stats['insertions'],\n            "lines_removed": stats['deletions']\n        }\n    except HTTPException:\n        raise\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=f"Commit failed: {str(e)}")\n\n\n@app.post("/git/push")\nasync def git_push(repo_name: str, branch: str, api_key: str = Security(verify_api_key)):\n    """Push commits to remote"""\n    try:\n        repo_path = os.path.join(REPOS_BASE_PATH, repo_name)\n        repo = git.Repo(repo_path)\n\n        if GITHUB_TOKEN:\n            with repo.config_writer() as git_config:\n                git_config.set_value('credential', 'helper', 'store')\n\n        origin = repo.remote('origin')\n        push_info = origin.push(branch)\n\n        return {\n            "status": "success",\n            "branch": branch,\n            "pushed": True\n        }\n    except HTTPException:\n        raise\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=f"Push failed: {str(e)}")\n\n\n# GitHub Operations\n@app.post("/github/fork")\nasync def github_fork_repo(request: GitHubForkRequest, api_key: str = Security(verify_api_key)):\n    """Fork a GitHub repository to your org"""\n    try:\n        if "/" not in request.source_repo:\n            raise HTTPException(status_code=400, detail="Repository must be in format 'owner/repo'")\n\n        async with httpx.AsyncClient(timeout=30.0) as client:\n            response = await client.post(\n                f"{GITHUB_API}/repos/{request.source_repo}/forks",\n                headers={\n                    "Authorization": f"token {GITHUB_TOKEN}",\n                    "Accept": "application/vnd.github.v3+json"\n                },\n                json={"organization": GITHUB_ORG} if GITHUB_ORG else {}\n            )\n\n            if response.status_code not in [200, 202]:\n                raise HTTPException(\n                    status_code=response.status_code,\n                    detail=f"GitHub API error: {response.text}"\n                )\n\n            fork_data = response.json()\n            repo_name = fork_data["name"]\n            clone_url = fork_data["clone_url"]\n            target_path = os.path.join(REPOS_BASE_PATH, repo_name)\n\n            if not os.path.exists(target_path):\n                git.Repo.clone_from(clone_url, target_path)\n\n            return {\n                "status": "success",\n                "fork_url": fork_data["html_url"],\n                "clone_url": fork_data["clone_url"],\n                "local_path": target_path,\n                "repo_name": repo_name\n            }\n    except HTTPException:\n        raise\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=f"Fork failed: {str(e)}")\n\n\n@app.get("/github/search")\nasync def github_search_repos(query: str, api_key: str = Security(verify_api_key)):\n    """Search GitHub for repositories"""\n    try:\n        async with httpx.AsyncClient(timeout=30.0) as client:\n            response = await client.get(\n                f"{GITHUB_API}/search/repositories",\n                headers={\n                    "Authorization": f"token {GITHUB_TOKEN}",\n                    "Accept": "application/vnd.github.v3+json"\n                },\n                params={\n                    "q": query,\n                    "sort": "stars",\n                    "order": "desc",\n                    "per_page": 20\n                }\n            )\n\n            if response.status_code != 200:\n                raise HTTPException(\n                    status_code=response.status_code,\n                    detail=f"GitHub API error: {response.text}"\n                )\n\n            results = response.json()\n\n            repos = []\n            for item in results.get("items", []):\n                repos.append({\n                    "full_name": item["full_name"],\n                    "description": item["description"],\n                    "stars": item["stargazers_count"],\n                    "language": item["language"],\n                    "url": item["html_url"],\n                    "clone_url": item["clone_url"]\n                })\n\n            return {\n                "status": "success",\n                "total_count": results.get("total_count", 0),\n                "repos": repos\n            }\n    except HTTPException:\n        raise\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=f"Search failed: {str(e)}")\n\n\n@app.get("/github/list-my-repos")\nasync def github_list_my_repos(api_key: str = Security(verify_api_key)):\n    """List all repos in your GitHub org/account"""\n    try:\n        async with httpx.AsyncClient(timeout=30.0) as client:\n            if GITHUB_ORG:\n                response = await client.get(\n                    f"{GITHUB_API}/orgs/{GITHUB_ORG}/repos",\n                    headers={\n                        "Authorization": f"token {GITHUB_TOKEN}",\n                        "Accept": "application/vnd.github.v3+json"\n                    },\n                    params={"per_page": 100}\n                )\n            else:\n                response = await client.get(\n                    f"{GITHUB_API}/user/repos",\n                    headers={\n                        "Authorization": f"token {GITHUB_TOKEN}",\n                        "Accept": "application/vnd.github.v3+json"\n                    },\n                    params={"per_page": 100}\n                )\n\n            if response.status_code != 200:\n                raise HTTPException(\n                    status_code=response.status_code,\n                    detail=f"GitHub API error: {response.text}"\n                )\n\n            repos = response.json()\n\n            repo_list = []\n            for repo in repos:\n                repo_list.append({\n                    "name": repo["name"],\n                    "full_name": repo["full_name"],\n                    "description": repo["description"],\n                    "private": repo["private"],\n                    "fork": repo["fork"],\n                    "url": repo["html_url"],\n                    "clone_url": repo["clone_url"]\n                })\n\n            return {\n                "status": "success",\n                "org": GITHUB_ORG or "personal",\n                "count": len(repo_list),\n                "repos": repo_list\n            }\n    except HTTPException:\n        raise\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=f"List repos failed: {str(e)}")\n\n\n@app.post("/github/create-pr")\nasync def github_create_pr(\n    repo_name: str,\n    title: str,\n    body: str,\n    head_branch: str,\n    base_branch: str = "main",\n    api_key: str = Security(verify_api_key)\n):\n    """Create a pull request on GitHub"""\n    try:\n        full_repo = f"{GITHUB_ORG}/{repo_name}" if GITHUB_ORG else repo_name\n\n        async with httpx.AsyncClient(timeout=30.0) as client:\n            response = await client.post(\n                f"{GITHUB_API}/repos/{full_repo}/pulls",\n                headers={\n                    "Authorization": f"token {GITHUB_TOKEN}",\n                    "Accept": "application/vnd.github.v3+json"\n                },\n                json={\n                    "title": title,\n                    "body": body,\n                    "head": head_branch,\n                    "base": base_branch\n                }\n            )\n\n            if response.status_code != 201:\n                raise HTTPException(\n                    status_code=response.status_code,\n                    detail=f"GitHub API error: {response.text}"\n                )\n\n            pr_data = response.json()\n\n            return {\n                "status": "success",\n                "pr_number": pr_data["number"],\n                "pr_url": pr_data["html_url"],\n                "state": pr_data["state"]\n            }\n    except HTTPException:\n        raise\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=f"PR creation failed: {str(e)}")\n\n\n# Build Operations\n@app.post("/build/execute")\nasync def build_execute(request: BuildRequest, api_key: str = Security(verify_api_key)):\n    """Execute a build command"""\n    try:\n        if request.repo_name not in ALLOWED_REPOS:\n            raise HTTPException(status_code=403, detail="Repository not allowed")\n\n        repo_path = os.path.join(REPOS_BASE_PATH, request.repo_name)\n\n        result = subprocess.run(\n            request.build_command,\n            shell=True,\n            cwd=repo_path,\n            capture_output=True,\n            text=True,\n            timeout=300\n        )\n\n        success = result.returncode == 0\n\n        async with db.pool.acquire() as conn:\n            await conn.execute("""\n                INSERT INTO build_results (session_id, build_status, build_output)\n                VALUES ($1, $2, $3)\n            """, request.session_id, "success" if success else "failed", result.stdout + result.stderr)\n\n        return {\n            "status": "success" if success else "failed",\n            "return_code": result.returncode,\n            "stdout": result.stdout,\n            "stderr": result.stderr\n        }\n    except subprocess.TimeoutExpired:\n        raise HTTPException(status_code=408, detail="Build timeout")\n    except HTTPException:\n        raise\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=f"Build failed: {str(e)}")\n\n\n# Context Operations\n@app.get("/context/session/{session_id}")\nasync def get_session_context(session_id: str, api_key: str = Security(verify_api_key)):\n    """Retrieve session context from database"""\n    try:\n        async with db.pool.acquire() as conn:\n            session = await conn.fetchrow(\n                "SELECT * FROM agent_sessions WHERE session_id = $1",\n                session_id\n            )\n\n            phases = await conn.fetch(\n                "SELECT * FROM agent_phases WHERE session_id = $1 ORDER BY created_at",\n                session_id\n            )\n\n            commits = await conn.fetch(\n                "SELECT * FROM git_commits WHERE session_id = $1",\n                session_id\n            )\n\n            return {\n                "session": dict(session) if session else None,\n                "phases": [dict(p) for p in phases],\n                "commits": [dict(c) for c in commits]\n            }\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=f"Context retrieval failed: {str(e)}")\n\n\n@app.get("/context/search")\nasync def search_context(\n    query: str,\n    limit: int = 10,\n    api_key: str = Security(verify_api_key)\n):\n    """Search past sessions by keyword in task descriptions and outputs"""\n    try:\n        async with db.pool.acquire() as conn:\n            sessions = await conn.fetch("""\n                SELECT DISTINCT s.session_id, s.task_description, s.status,\n                       s.created_at, s.completed_at\n                FROM agent_sessions s\n                WHERE s.task_description ILIKE $1\n                ORDER BY s.created_at DESC\n                LIMIT $2\n            """, f"%{query}%", limit)\n\n            phases = await conn.fetch("""\n                SELECT DISTINCT p.session_id, p.phase_name, p.output_content,\n                       p.created_at, s.task_description\n                FROM agent_phases p\n                JOIN agent_sessions s ON p.session_id = s.session_id\n                WHERE p.output_content ILIKE $1 OR p.input_context ILIKE $1\n                ORDER BY p.created_at DESC\n                LIMIT $2\n            """, f"%{query}%", limit)\n\n            results = {\n                "query": query,\n                "sessions_found": len(sessions),\n                "phases_found": len(phases),\n                "sessions": [dict(s) for s in sessions],\n                "matching_phases": [dict(p) for p in phases]\n            }\n\n            return results\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=f"Search failed: {str(e)}")\n\n\n@app.get("/context/similar")\nasync def find_similar_sessions(\n    task: str,\n    limit: int = 5,\n    api_key: str = Security(verify_api_key)\n):\n    """Find sessions similar to the given task description"""\n    try:\n        keywords = [w.lower() for w in task.split() if len(w) > 3]\n\n        if not keywords:\n            return {"similar_sessions": []}\n\n        async with db.pool.acquire() as conn:\n            similar = await conn.fetch("""\n                SELECT s.session_id, s.task_description, s.status,\n                       s.created_at, s.completed_at,\n                       (\n                           SELECT COUNT(*) FROM agent_phases p\n                           WHERE p.session_id = s.session_id AND p.success = true\n                       ) as successful_phases\n                FROM agent_sessions s\n                WHERE """ + " OR ".join([f"s.task_description ILIKE ${i+1}" for i in range(len(keywords[:5]))]) + """\n                ORDER BY s.created_at DESC\n                LIMIT $""" + str(len(keywords[:5]) + 1),\n                *[f"%{kw}%" for kw in keywords[:5]], limit\n            )\n\n            results = []\n            for session in similar:\n                session_dict = dict(session)\n\n                phases = await conn.fetch("""\n                    SELECT phase_name, model_used, success,\n                           LEFT(output_content, 500) as output_preview\n                    FROM agent_phases\n                    WHERE session_id = $1\n                    ORDER BY created_at\n                """, session['session_id'])\n\n                session_dict['phases'] = [dict(p) for p in phases]\n                results.append(session_dict)\n\n            return {\n                "task": task,\n                "keywords_used": keywords[:5],\n                "similar_sessions": results\n            }\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=f"Similar search failed: {str(e)}")\n\n\n@app.get("/context/recent")\nasync def get_recent_sessions(\n    limit: int = 10,\n    status: Optional[str] = None,\n    api_key: str = Security(verify_api_key)\n):\n    """Get recent sessions, optionally filtered by status"""\n    try:\n        async with db.pool.acquire() as conn:\n            if status:\n                sessions = await conn.fetch("""\n                    SELECT s.session_id, s.task_description, s.status,\n                           s.created_at, s.completed_at,\n                           (SELECT COUNT(*) FROM agent_phases p\n                            WHERE p.session_id = s.session_id) as total_phases,\n                           (SELECT COUNT(*) FROM agent_phases p\n                            WHERE p.session_id = s.session_id AND p.success = true) as successful_phases\n                    FROM agent_sessions s\n                    WHERE s.status = $1\n                    ORDER BY s.created_at DESC\n                    LIMIT $2\n                """, status, limit)\n            else:\n                sessions = await conn.fetch("""\n                    SELECT s.session_id, s.task_description, s.status,\n                           s.created_at, s.completed_at,\n                           (SELECT COUNT(*) FROM agent_phases p\n                            WHERE p.session_id = s.session_id) as total_phases,\n                           (SELECT COUNT(*) FROM agent_phases p\n                            WHERE p.session_id = s.session_id AND p.success = true) as successful_phases\n                    FROM agent_sessions s\n                    ORDER BY s.created_at DESC\n                    LIMIT $1\n                """, limit)\n\n            return {\n                "status_filter": status,\n                "count": len(sessions),\n                "sessions": [dict(s) for s in sessions]\n            }\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=f"Recent sessions retrieval failed: {str(e)}")\n\n\n@app.post("/context/log-phase")\nasync def log_phase(\n    session_id: str,\n    phase_name: str,\n    model: str,\n    input_context: str,\n    output: str,\n    tokens_used: int,\n    duration_ms: int,\n    success: bool,\n    error_message: Optional[str] = None,\n    api_key: str = Security(verify_api_key)\n):\n    """Log a phase execution"""\n    try:\n        await db.log_phase(\n            session_id, phase_name, model, input_context,\n            output, tokens_used, duration_ms, success, error_message\n        )\n        return {"status": "logged", "session_id": session_id, "phase": phase_name}\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=f"Logging failed: {str(e)}")\n\n\n@app.post("/context/create-session")\nasync def create_session(\n    task_description: str,\n    metadata: Optional[dict] = None,\n    api_key: str = Security(verify_api_key)\n):\n    """Create a new agent session"""\n    try:\n        session_id = await db.create_session(task_description, metadata)\n        return {"status": "created", "session_id": session_id}\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=f"Session creation failed: {str(e)}")\n\n\n# Startup and shutdown\n@app.on_event("startup")\nasync def startup():\n    """Initialize database connection pool on startup"""\n    await db.init_pool()\n    print("=" * 60)\n    print("✓ MCP Server started successfully")\n    print(f"✓ Database: {DB_CONFIG['host']}:{DB_CONFIG['port']}/{DB_CONFIG['database']}")\n    print(f"✓ Repos: {REPOS_BASE_PATH}")\n    print(f"✓ Allowed repos: {ALLOWED_REPOS}")\n    print(f"✓ GitHub org: {GITHUB_ORG or 'personal account'}")\n    print(f"✓ Multi-user auth: Enabled (Keycloak JWT + API Key)")\n    print("=" * 60)\n\n\n@app.on_event("shutdown")\nasync def shutdown():\n    """Close database connections on shutdown"""\n    if db.pool:\n        await db.pool.close()\n    print("✓ MCP Server shut down gracefully")\n\n\nif __name__ == "__main__":\n    import uvicorn\n    host = os.getenv("MCP_HOST", "0.0.0.0")\n    port = int(os.getenv("MCP_PORT", 8082))\n    print(f"Starting MCP Server on {host}:{port}")\n    uvicorn.run(app, host=host, port=port, log_level="info")\n\n\n# ============================\n# REACTOR UI COMPATIBILITY\n# ============================\n\nfrom fastapi import APIRouter\n\n_ui_router = APIRouter(prefix="/api")\n\n@_ui_router.get("/models/status")\nasync def models_status():\n    return {\n        "status": "ok",\n        "models": []\n    }\n\n@_ui_router.get("/tasks")\nasync def tasks_list():\n    return {\n        "tasks": []\n    }\n\napp.include_router(_ui_router)\n\n
# ============================
# REACTOR UI COMPATIBILITY
# ============================

from fastapi import APIRouter

_ui_router = APIRouter(prefix="/api")

@_ui_router.get("/models/status")
async def models_status():
    return {
        "status": "ok",
        "models": []
    }

@_ui_router.get("/tasks")
async def tasks_list():
    return {
        "tasks": []
    }

app.include_router(_ui_router)
