from fastapi import FastAPI, Depends, HTTPException, UploadFile, File
from fastapi.security import APIKeyHeader
from pydantic import BaseModel
from typing import List, Dict
import uuid
import os
import json
import time
from pathlib import Path

app = FastAPI(title="MCP Backend API")

# =========================
# AUTH
# =========================

API_KEY_HEADER = APIKeyHeader(name="X-API-Key", auto_error=False)

def require_key(key: str = Depends(API_KEY_HEADER)):
    if key != os.getenv("MCP_API_KEY"):
        raise HTTPException(status_code=403, detail="Invalid API key")

# =========================
# DATA MODELS
# =========================

class PipelineRequest(BaseModel):
    task: str
    session_id: str
    rag_ids: List[str] = []

class PipelineResponse(BaseModel):
    run_id: str
    status: str
    output: Dict

# =========================
# HEALTH
# =========================

@app.get("/health")
def health():
    return {"status": "ok"}

@app.get("/api/health")
def api_health():
    return {
        "status": "healthy",
        "ollama": {"status": "connected", "models": ["hermes3:70b", "qwen2.5-coder:32b"]},
        "database": {"status": "connected"},
        "forgejo": {"status": "connected", "url": "https://vault.wopr.systems"},
        "mcp": {"status": "running", "port": 7003},
        "version": "1.0.0"
    }

# =========================
# MODELS
# =========================

@app.get("/api/models")
def models():
    return {
        "models": [
            {"id": "agent", "type": "pipeline", "status": "active"}
        ]
    }

# =========================
# RAG UPLOAD
# =========================

RAG_DIR = "/opt/mcp-agent/rag"
os.makedirs(RAG_DIR, exist_ok=True)

@app.post("/api/rag/upload", dependencies=[Depends(require_key)])
async def upload_rag(files: List[UploadFile] = File(...)):
    rag_ids = []
    for f in files:
        rid = str(uuid.uuid4())
        path = os.path.join(RAG_DIR, f"{rid}_{f.filename}")
        with open(path, "wb") as out:
            out.write(await f.read())
        rag_ids.append(rid)
    return {"rag_ids": rag_ids}

# =========================
# PIPELINE
# =========================

@app.post("/api/pipeline/run", response_model=PipelineResponse, dependencies=[Depends(require_key)])
def run_pipeline(req: PipelineRequest):
    run_id = str(uuid.uuid4())
    
    # Validate RAG IDs
    for rid in req.rag_ids:
        if not any(rid in name for name in os.listdir(RAG_DIR)):
            raise HTTPException(status_code=400, detail=f"Missing RAG ID: {rid}")
    
    # Create run directory and persist artifacts
    run_dir = Path("/opt/mcp-agent/runs") / run_id
    run_dir.mkdir(parents=True, exist_ok=True)
    
    # Write input
    (run_dir / "input.json").write_text(json.dumps({
        "task": req.task,
        "rag_ids": req.rag_ids,
        "session_id": req.session_id,
        "timestamp": time.time()
    }, indent=2))
    
    # Prepare output
    output_data = {
        "run_id": run_id,
        "status": "completed",
        "output": {
            "task": req.task,
            "rag_used": req.rag_ids,
            "message": "Pipeline executed successfully"
        }
    }
    
    # Write output
    (run_dir / "output.json").write_text(json.dumps(output_data, indent=2))
    
    return output_data




@app.get("/api/runs")
def list_runs(limit: int = 50):
    runs_dir = Path("/opt/mcp-agent/runs")
    if not runs_dir.exists():
        return {"runs": [], "count": 0}

    runs = []
    for d in sorted(runs_dir.iterdir(), key=lambda x: x.stat().st_mtime, reverse=True)[:limit]:
        if not d.is_dir():
            continue

        run = {
            "run_id": d.name,
            "created": d.stat().st_mtime,
        }

        ip = d / "input.json"
        op = d / "output.json"

        if ip.exists():
            run["input"] = json.loads(ip.read_text())
        if op.exists():
            run["output"] = json.loads(op.read_text())

        runs.append(run)

    return {"runs": runs, "count": len(runs)}


@app.get("/api/runs/{run_id}")
def get_run(run_id: str):
    d = Path("/opt/mcp-agent/runs") / run_id
    if not d.exists():
        raise HTTPException(status_code=404, detail="Run not found")

    run = {
        "run_id": run_id,
        "created": d.stat().st_mtime,
    }

    ip = d / "input.json"
    op = d / "output.json"

    if ip.exists():
        run["input"] = json.loads(ip.read_text())
    if op.exists():
        run["output"] = json.loads(op.read_text())

    return run


print("âœ“ MCP Backend loaded cleanly")
